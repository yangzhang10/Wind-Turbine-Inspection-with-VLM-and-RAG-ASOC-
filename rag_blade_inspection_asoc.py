# -*- coding: utf-8 -*-
"""RAG_Blade_Inspection_ASOC.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bD8eD8edFJGkPXuFYhIFPJ6EOZxBMdsX
"""

!pip install faiss-cpu

"""## Define RAG"""

import os
from openai import OpenAI
import json
from typing import List, Dict, Any, Optional
import os
import glob
from pathlib import Path
import numpy as np
from PIL import Image
import faiss
from sentence_transformers import SentenceTransformer
import pandas as pd
import os
import requests
import csv
import re
import time


class DamageDetectionRAG:
    def __init__(
        self,
        api_key: str,
        base_url: str = "https://dashscope.aliyuncs.com/compatible-mode/v1",
        model_name: str = "qwen-vl-max",
        embedding_model_name: str = "all-MiniLM-L6-v2",
        kb_path: str = "knowledge_base",
        image_path: str = "reference_images"
    ):
        """
        Initialize the RAG-based Damage Detection system

        Args:
            api_key: API key for the OpenAI-compatible API
            base_url: Base URL for the API
            model_name: Model name to use for damage detection
            embedding_model_name: Model to use for text embeddings
            kb_path: Path to knowledge base documents
            image_path: Path to reference images
        """
        self.client = OpenAI(
            api_key=api_key,
            base_url=base_url,
        )
        self.model_name = model_name
        self.embedding_model = SentenceTransformer(embedding_model_name)
        self.kb_path = kb_path
        self.image_path = image_path

        # Create knowledge base directory if it doesn't exist
        os.makedirs(kb_path, exist_ok=True)
        os.makedirs(image_path, exist_ok=True)

        # Initialize knowledge base
        self.knowledge_base = []
        self.knowledge_embeddings = None
        self.index = None

        # Load knowledge base if exists
        self._load_knowledge_base()

    def _load_knowledge_base(self):
        """Load and index the knowledge base documents"""
        print("Loading knowledge base...")

        # Load text documents
        text_files = glob.glob(os.path.join(self.kb_path, "*.txt"))
        for file_path in text_files:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
                doc_id = Path(file_path).stem
                self.knowledge_base.append({
                    "id": doc_id,
                    "content": content,
                    "type": "text"
                })

        # Load JSON documents (if any)
        json_files = glob.glob(os.path.join(self.kb_path, "*.json"))
        for file_path in json_files:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = json.load(f)
                doc_id = Path(file_path).stem
                self.knowledge_base.append({
                    "id": doc_id,
                    "content": json.dumps(content),
                    "type": "json"
                })

        # Create embeddings for documents
        if self.knowledge_base:
            docs = [item["content"] for item in self.knowledge_base]
            self.knowledge_embeddings = self.embedding_model.encode(docs)

            # Create FAISS index
            self.index = faiss.IndexFlatL2(self.knowledge_embeddings.shape[1])
            self.index.add(self.knowledge_embeddings.astype(np.float32))

            print(f"Loaded {len(self.knowledge_base)} documents into knowledge base")
        else:
            print("No documents found in knowledge base directory")

    def add_document(self, content: str, doc_id: str, doc_type: str = "text"):
        """
        Add a document to the knowledge base

        Args:
            content: Document content
            doc_id: Document ID/name
            doc_type: Document type (text or json)
        """
        if doc_type == "json" and isinstance(content, dict):
            content = json.dumps(content)

        # Save to file
        file_ext = "json" if doc_type == "json" else "txt"
        file_path = os.path.join(self.kb_path, f"{doc_id}.{file_ext}")

        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(content)

        # Add to knowledge base
        self.knowledge_base.append({
            "id": doc_id,
            "content": content,
            "type": doc_type
        })

        # Update embeddings and index
        embedding = self.embedding_model.encode([content])[0]

        if self.knowledge_embeddings is None:
            self.knowledge_embeddings = np.array([embedding])
            self.index = faiss.IndexFlatL2(embedding.shape[0])
            self.index.add(self.knowledge_embeddings.astype(np.float32))
        else:
            self.knowledge_embeddings = np.vstack([self.knowledge_embeddings, embedding])
            self.index = faiss.IndexFlatL2(self.knowledge_embeddings.shape[1])
            self.index.add(self.knowledge_embeddings.astype(np.float32))

        print(f"Added document '{doc_id}' to knowledge base")

    def add_reference_image(self, image_path: str, damage_type: str, description: str):
        """
        Add a reference image to the knowledge base

        Args:
            image_path: Path to the image file
            damage_type: Type of damage shown in the image
            description: Description of the image
        """
        # Copy image to reference folder
        img = Image.open(image_path)
        filename = f"{damage_type}_{os.path.basename(image_path)}"
        save_path = os.path.join(self.image_path, filename)
        img.save(save_path)

        # Create metadata JSON
        metadata = {
            "damage_type": damage_type,
            "description": description,
            "image_path": save_path
        }

        # Add metadata to knowledge base
        self.add_document(
            content=metadata,
            doc_id=f"img_{damage_type}_{Path(image_path).stem}",
            doc_type="json"
        )

        print(f"Added reference image for '{damage_type}' damage")

    def retrieve_relevant_context(self, query: str, top_k: int = 3) -> List[Dict]:
        """
        Retrieve relevant documents from knowledge base

        Args:
            query: Query text
            top_k: Number of documents to retrieve

        Returns:
            List of relevant documents
        """
        if not self.knowledge_base:
            print("Knowledge base is empty")
            return []

        # Encode query
        query_embedding = self.embedding_model.encode([query])[0]

        # Search index
        D, I = self.index.search(np.array([query_embedding]).astype(np.float32), min(top_k, len(self.knowledge_base)))

        # Retrieve relevant documents
        relevant_docs = [self.knowledge_base[i] for i in I[0]]

        return relevant_docs

    def detect_damage(self, image_url: str, custom_prompt: Optional[str] = None) -> Dict[str, Any]:
        """
        Detect damage in the given image

        Args:
            image_url: URL to the image
            custom_prompt: Custom prompt override

        Returns:
            Detection results
        """
        print(f"Detecting damage in image: {image_url}")

        # Default query for retrieving relevant context
        default_query = "comprehensive wind turbine blade damage assessment guidelines including technical documentation" #"wind turbine blade damage visual characteristics identification guide"
        # default_query = "comprehensive wind turbine components surface damage assessment guidelines including technical documentation"

        # Retrieve relevant context
        relevant_docs = self.retrieve_relevant_context(default_query)

        # Build prompt with retrieved context
        prompt = "I need to identify damage on wind turbine blades. "
        # prompt = "I need to identify damage on the image taken for the wind turbine components. "
        prompt += "Using the following reference information to help with the analysis:\n\n"

        for doc in relevant_docs:
            if doc["type"] == "text":
                prompt += f"{doc['content']}\n\n"
            elif doc["type"] == "json":
                try:
                    content = json.loads(doc["content"])
                    if "damage_type" in content and "description" in content:
                        prompt += f"Reference for {content['damage_type']}: {content['description']}\n\n"
                except:
                    pass

        prompt += "\nBased on these descriptions, analyze the image and determine:\n"
        prompt += "1. How many blades are visible in the image?\n"
        prompt += "2. Is there visible damage on any of the turbine blades in the image?\n"
        prompt += "3. If yes, what specific type of damage can be identified?\n"
        prompt += "4. Provide a detailed description of the damage observed, referencing the specific characteristics described above.\n"
        prompt += "5. Rate the severity of the damage on a scale of 1-5, where 1 is minor and 5 is severe.\n"
        prompt += "\nBe specific about which damage type is present based on visual evidence. If no damage is visible, clearly state that."

        # Override with custom prompt if provided
        if custom_prompt:
            prompt = custom_prompt

        # Call API
        try:
            print("Sending request to API...")
            completion = self.client.chat.completions.create(
                model=self.model_name,
                messages=[{
                    "role": "user",
                    "content": [
                        {"type": "text", "text": prompt},
                        {"type": "image_url", "image_url": {"url": image_url}}
                    ]
                }],
                timeout=60
            )

            # Extract content from response
            response_content = completion.choices[0].message.content
            print(f"Received response: {response_content[:100]}...")

            # Parse structured information if possible
            result = {
                "raw_response": response_content,
                "damage_detected": False,
                "damage_types": [],
                "severity": None,
                "description": ""
            }

            # Check if damage is mentioned as present
            damage_indicators = [
                "damage (is|was) (detected|found|visible|present)",
                "there (is|are) damage",
                "blade (has|shows|exhibits|contains) damage",
                "damaged",
                "signs of damage"
            ]

            for indicator in damage_indicators:
                if re.search(indicator, response_content, re.IGNORECASE):
                    result["damage_detected"] = True
                    break

            # Explicit check for no damage phrases
            no_damage_indicators = [
                "no damage",
                "no visible damage",
                "does not show any damage",
                "healthy condition",
                "no signs of damage"
            ]

            for indicator in no_damage_indicators:
                if indicator in response_content.lower():
                    result["damage_detected"] = False
                    break

            # Extract damage types more intelligently
            damage_types = ["Crack", "Corrosion", "Rust", "Delamination", "Fracture",
                            "Dent", "Ice", "Snow", "Surface Peeling", "Wear","Lightning Strike/Burning", "Impact damage"]

            found_types = []
            for damage_type in damage_types:
                # Check for stronger indications that the damage type is actually present
                if re.search(rf"{damage_type}s?\b", response_content, re.IGNORECASE):
                    # Avoid phrases like "no cracks" or "absence of cracks"
                    negations = [
                        f"no {damage_type}s?",
                        f"not {damage_type}s?",
                        f"absence of {damage_type}s?",
                        f"free of {damage_type}s?",
                        f"without {damage_type}s?"
                    ]

                    negated = False
                    for negation in negations:
                        if re.search(negation, response_content, re.IGNORECASE):
                            negated = True
                            break

                    if not negated:
                        found_types.append(damage_type)

            result["damage_types"] = found_types

            # Try to extract severity rating
            severity_match = re.search(r"severity[:\s]+(\d)[\s\.,/]", response_content, re.IGNORECASE)
            if severity_match:
                result["severity"] = int(severity_match.group(1))

            # Use the raw response as description
            result["description"] = response_content

            # Ensure consistency between damage_detected and damage_types
            if result["damage_types"] and not result["damage_detected"]:
                result["damage_detected"] = True

            return result

        except Exception as e:
            print(f"Error calling API: {e}")
            return {
                "error": str(e),
                "image_url": image_url,
                "timestamp": time.strftime("%Y-%m-%d %H:%M:%S")
            }


    def batch_detect(self, image_urls: List[str]) -> List[Dict[str, Any]]:
        """
        Run damage detection on multiple images

        Args:
            image_urls: List of image URLs

        Returns:
            List of detection results
        """
        results = []
        for url in image_urls:
            result = self.detect_damage(url)
            results.append({
                "image_url": url,
                "result": result
            })

        return results

    def export_results(self, results: List[Dict[str, Any]], output_path: str):
        """
        Export detection results to CSV

        Args:
            results: List of detection results
            output_path: Path to save the CSV file
        """
        rows = []
        for item in results:
            row = {
                "image_url": item["image_url"],
                "damage_detected": item["result"].get("damage_detected", False),
                "damage_types": ", ".join(item["result"].get("damage_types", [])),
                "severity": item["result"].get("severity", ""),
                "description": item["result"].get("description", "")
            }
            rows.append(row)

        df = pd.DataFrame(rows)
        df.to_csv(output_path, index=False)
        print(f"Results exported to {output_path}")

"""## Loading knowledge database"""

# from damage_detection_rag import DamageDetectionRAG

# Initialize the RAG system
# Put your API key here:

rag = DamageDetectionRAG(
    api_key="sk-#####",
)

# Step 1: Add knowledge base documents
# Add detailed damage type descriptions
damage_descriptions = """
Here are the descriptions for each damage type:

0. **Healthy**: A healthy blade condition exhibits no obvious damage characteristics, maintaining its original design profile and surface properties. It's worth noting that the blade surface may have dust, dirt, or other environmental residues, which are not damage but normal accumulations from regular use. Manufacturing seam lines, assembly marks, or material textures may appear prominent under certain lighting conditions. Camera angles, light reflections, and shadow effects can cause certain areas to appear abnormal in images, but these are merely visual effects rather than actual damage. When conducting condition assessments, care should be taken to distinguish these surface phenomena from genuine structural damage to avoid misdiagnosis of perfectly functional components.

1. **Cracks**: Crack damage looks like linear fractures on the blade surface, often appearing as fine lines that can range from microscopic to several centimeters in length. They typically start at stress concentration points and may be straight, branched, or web-like. Fresh cracks appear as sharp, clean breaks with defined edges, while older cracks may have discoloration around the edges. They can be superficial (affecting only the outer layer) or structural (penetrating deeper into the blade material). The obvious features for the cracks are that they are perpendicular to the length of the blade.

2. **Corrosion or Rust**: Corrosion or rust looks like reddish-brown, orange, or yellowish discoloration on metal components of the turbine (particularly at joints, bolts, or metal fixtures). But the image took by camera may not show the color. So the area may be black. Affected areas often have a rough, flaky texture with visible pitting or material loss. Severe corrosion may present as holes or significant thinning of the metal. In coastal areas, salt-induced corrosion appears as whitish salt deposits mixed with rust. On non-metal parts, corrosion effects may manifest as material degradation around metal fixtures.

3. **Delamination**: Delamination appears as a separation or splitting between the layers of composite materials in the blade. Visually, it presents as bubbles, bulges, or raised areas on the blade surface where layers have separated. When tapped, delaminated areas produce a hollow or dull sound compared to the solid sound of intact areas. In advanced stages, you may see clear separation of material layers, with gaps or voids between them. Delamination often occurs along with other damage types and may have whitish or discolored areas around the affected region.

4. **Fracture**: Fracture damage presents as complete or partial breaks in the blade structure, where the material has completely failed and separated. Unlike cracks, fractures involve complete separation of material, with visible gaps, jagged edges, and exposed internal structure of the blade. Fractured areas often show fiber tear-out in composite materials, with frayed or splayed fibers visible at the break point. The surrounding area may display stress whitening or discoloration extending from the fracture site. In severe cases, fractures can lead to partial detachment of blade segments.

5. **Dent**: Dent damage presents as localized depressions or indentations on the blade surface, where the material has been physically displaced inward without material removal. These concave deformations disrupt the original aerodynamic profile and can vary in size from small dimples to larger, more significant depressions. The affected areas typically display sharp transitions between the undamaged surface and the depressed region, often with stress marks or paint cracking radiating from the impact point. In severe cases, the deformation may cause internal structural weakening not visible from the surface. Dent damage patterns are usually irregular and isolated, indicating discrete impact events rather than continuous wear processes, and may be accompanied by scratches or gouges if the impact involved sliding contact.

6. **Ice/Snow**: Ice and snow accumulation appears as white or translucent buildup on the blade surfaces, with thickness varying from a thin layer to substantial accumulation. Fresh snow appears as a fluffy white covering, while ice typically forms as a transparent or translucent layer with a glossy appearance. Ice accumulation is often uneven, with more buildup on the leading edge and thinner areas toward the trailing edge. In severe cases, icicles may form on the lower edge of the blade. The boundary between ice-covered and clean areas is typically well-defined, often with a visible line marking the transition.

7. **Surface Peeling**: Surface peeling appears as areas where the outer coating or paint layer is detaching from the blade surface, similar to peeling paint on a wall. It typically begins with small areas of coating lifting away from the substrate, with visible edges curling up. The underside of the peeled coating often has a different color or texture than the surface. Beneath the peeled coating, the exposed substrate may appear discolored or have a different texture. Peeling frequently begins at existing damage sites, edges, or areas of high environmental exposure. In advanced stages, large sections of coating may be missing entirely, creating a patchwork appearance on the blade surface.

8. **Lightning Strike/Burning**: Lightning strike damage appears as localized areas with distinct burn marks, carbonization, and structural damage on the blade surface. The damage typically begins with an entry point characterized by a circular or irregular-shaped puncture with carbonized or charred edges showing black or dark brown discoloration. Melted composite material is often visible around the entry point, with diameters ranging from a few centimeters to 15+ cm depending on strike intensity. The damage path often follows conductive components, appearing as elongated scorch marks or jagged, branching patterns (Lichtenberg figures) particularly on internal surfaces. These carbonized lines vary in width from 5mm to several centimeters. Surrounding the strike path, structural delamination may be visible as separation of composite layers, revealing underlying glass or carbon fiber materials. The affected areas emit a distinct burnt odor when recently damaged and show layer-by-layer thermal decomposition. In advanced cases, the damage extends to surface arcing marks appearing as small burn marks in linear or branching arrangements, often originating from metal components or receptors, and potentially spanning several meters from the initial strike point.

9. **Impact Damage**: Impact damage appears as localized areas with distinctive circular or irregular-shaped indentations on the blade surface, often resulting from collision with solid objects. The damage typically presents with a central depression or puncture surrounded by radiating cracks extending outward from the impact point. These radiating cracks often form a star or spider-web pattern, with the most severe fractures closest to the center. The impact site may show discoloration ranging from light yellow to brown around the edges, without the deep carbonization seen in lightning strikes. In larger impacts, the damage may include visible delamination where composite layers separate near the impact zone, creating a bulging effect around the depression. Multiple small impacts may appear as a pattern of dents across the blade surface. Common causes include bird strikes, hail, airborne debris, or accidental tool impacts during maintenance. The severity ranges from superficial surface damage to complete penetration through the blade shell, with moderate impacts often showing exposed underlying fiber layers around the perimeter of the impact site.

"""


# Add to knowledge base
rag.add_document(damage_descriptions, "damage_type_descriptions")

# Step 2: Add domain-specific information about wind turbine blades
turbine_info = """
Wind turbine blades are typically made of composite materials, primarily fiberglass reinforced polyester or epoxy, and sometimes carbon fiber for larger blades. The typical structure includes:
0. This is very important. The blade is usally paited with white color. If there is damage, it will shown in different color, mainly in black.
1. A load-bearing spar or spar caps running the length of the blade
2. Leading and trailing edge reinforcements
3. Outer shell or skin made of composite materials
4. Protective coating and paint to shield against environmental elements
5. Root section reinforced with metal for connection to the hub
6. There is usually seam line on the back side of blade, along the length direction but it is not damage.
7, The pictures taken for the blade may be at dusk, night. The vision will be not good.
8, Vortex generators (small triangular or fin-shaped protrusions arranged in regular patterns on the blade surface).
9, Lightning protection receptors (metal discs or protrusions at regular intervals, especially near the blade tip).
10, Inspection hatches and access panels (rectangular or circular panels with visible edges and sometimes slight color differences).
11, Intentional blade markings such as manufacturer logos, serial numbers, or position indicators (often appearing as painted symbols or raised lettering).

Common damage areas:
- Leading edge: Most susceptible to erosion and wear
- Trailing edge: Often experiences cracks and delamination
- Root section: Subject to high stress and potential for fatigue damage
- Tip: Can experience lightning strikes and impact damage

Environmental factors affecting damage:
- UV radiation causes material degradation over time
- Salt in coastal areas accelerates corrosion
- Rain, hail, and airborne particles cause erosion
- Freeze-thaw cycles contribute to delamination
- Lightning strikes can cause significant localized damage
- There will be dust, dirt, or other environmental residues on the blade, which are not damage but normal accumulations from regular use.
"""
rag.add_document(turbine_info, "turbine_blade_information")

# Step 3: Add maintenance guidelines
maintenance_info = """
Damage severity classification:

Level 1 (Minor): Superficial damage that does not affect structural integrity or performance. Examples include minor surface erosion, small scratches, or minor coating damage. Monitoring recommended.

Level 2 (Low): Early stage damage that may progress if not addressed but does not present immediate concern. Examples include small cracks less than 10cm, early stage leading edge erosion, or limited surface peeling. Scheduled repair recommended within 3-6 months.

Level 3 (Moderate): Damage that affects aerodynamic performance and may progress to structural issues if not addressed. Examples include leading edge erosion exposing composite materials, multiple cracks, moderate delamination, or extensive surface peeling. Repair recommended within 1-3 months.

Level 4 (Significant): Damage that affects structural integrity and requires prompt attention. Examples include through-thickness cracks, severe delamination, or significant material loss. Repair required within 2-4 weeks or operational limitations should be implemented.

Level 5 (Severe): Critical damage that compromises the safety and functionality of the blade. Examples include large fractures, extensive delamination affecting structural elements, or severe structural damage. Immediate shutdown and repair required.
"""
rag.add_document(maintenance_info, "maintenance_guidelines")

# Step 4: Add reference images (you would need actual images)
# Uncomment and adjust paths when you have reference images


def download_image(url, save_path):
    """Download an image from a URL and save it to the specified path"""
    try:
        response = requests.get(url, timeout=10)
        response.raise_for_status()

        # Create directory if it doesn't exist
        os.makedirs(os.path.dirname(save_path), exist_ok=True)

        # Save the image
        with open(save_path, 'wb') as f:
            f.write(response.content)

        print(f"Downloaded image to {save_path}")
        return True
    except Exception as e:
        print(f"Error downloading image from {url}: {e}")
        return False

def extract_damage_type(description):
    """Extract the damage type from the description"""
    # Common damage types to look for in the description
    damage_types = [
          "Crack", "Corrosion", "Rust", "Delamination", "Fracture",
          "Wear", "Ice", "Snow", "Surface Peeling", "Dent","impact damage","Lightning Strike/Burning","Burn Mark"
    ]

    # Check if any damage type is explicitly mentioned in the description
    for damage_type in damage_types:
        if damage_type.lower() in description.lower():
            return damage_type

    # Default to "Unspecified" if no damage type is found
    return "Unspecified"

def load_reference_images(csv_path, rag_instance, reference_dir="reference_images"):
    """Load reference images from CSV with descriptions and add them to RAG system"""
    # Create reference images directory if it doesn't exist
    os.makedirs(reference_dir, exist_ok=True)

    # Track statistics
    total_processed = 0
    damage_counts = {}

    # Read the CSV file
    with open(csv_path, newline='', encoding='utf-8') as csvfile:
        reader = csv.DictReader(csvfile)

        # Process each row
        for i, row in enumerate(reader, 1):
            # Extract fields from the CSV
            object_name = row.get('object', f"unknown_{i}")
            url = row.get('url', '')
            description = row.get('descriptions', '')

            if not url:
                print(f"Skipping row {i}: No URL provided")
                continue

            if not description:
                print(f"Skipping row {i}: No description provided")
                continue

            # Extract the filename from the URL
            filename = url.split('/')[-1]

            # Create a clean local filename
            clean_filename = re.sub(r'[^a-zA-Z0-9_.-]', '_', filename)
            save_path = os.path.join(reference_dir, clean_filename)

            # Download the image
            if download_image(url, save_path):
                # Try to extract damage type from description or use a default value
                damage_type = extract_damage_type(description)

                # Add the reference image to the RAG system
                try:
                    rag_instance.add_reference_image(save_path, damage_type, description)
                    print(f"Added reference image for {damage_type}: {description[:50]}...")

                    # Update statistics
                    total_processed += 1
                    damage_counts[damage_type] = damage_counts.get(damage_type, 0) + 1

                except Exception as e:
                    print(f"Error adding reference image to RAG system: {e}")

            # Add a small delay to avoid hitting rate limits
            time.sleep(0.5)

# store your reference image links in csv file and put the data here.
load_reference_images("/content/***.csv", rag)

"""## Inspection on testing datasets"""

import json
import os
import time
import pandas as pd
import re

def extract_damage_detection(raw_response):
    """
    Extract if damage is detected from the raw response text.
    Focus primarily on question 2 but also look for direct statements.

    Args:
        raw_response: The raw text response from the model

    Returns:
        Boolean indicating if damage is detected
    """
    if not raw_response:
        return False

    # Convert to string and lowercase for consistency
    response_lower = raw_response.lower()

    # Check for direct statements about damage presence
    direct_damage_statements = [
        "visible damage: yes",
        "there is visible damage",
        "damage is present",
        "blade is damaged",
        "shows damage"
    ]

    for statement in direct_damage_statements:
        if statement in response_lower:
            return True

    # Find question 2's answer using broader patterns
    q2_patterns = [
        r"2\.\s*\*\*is there visible damage.*?\*\*\s*-\s*(.*?)(?=\n\n|\n3\.)",
        r"visible damage.*?\n\s*-\s*(.*?)(?=\n\n)",
        r"visible damage[:\s]+(.*?)(?=\n)"
    ]

    for pattern in q2_patterns:
        match = re.search(pattern, response_lower, re.DOTALL)
        if match:
            answer = match.group(1).strip()

            # Check for affirmative answers
            if "yes" in answer:
                return True

            # Check for negative answers
            if "no" in answer:
                return False

    # If we can't find a direct answer, check for specific phrases
    if "no visible damage" in response_lower or "no damage" in response_lower:
        return False

    if "visible damage" in response_lower and "no visible damage" not in response_lower:
        return True

    # Look for damage descriptions as fallback
    damage_indicators = ["crack", "corrosion", "rust", "delamination", "fracture",
                         "edge splitting", "burn mark", "surface peeling","lightning strike/burning"]

    damage_description_patterns = [
        r"damage observed[:\s]+(.*?)(?=\n)",
        r"detailed description of damage[:\s]+(.*?)(?=\n)",
        r"specific type of damage[:\s]+(.*?)(?=\n)"
    ]

    # Check if any damage type is mentioned in a way that indicates presenceb
    for pattern in damage_description_patterns:
        match = re.search(pattern, response_lower, re.DOTALL)
        if match:
            description = match.group(1).strip()
            for indicator in damage_indicators:
                if indicator in description and f"no {indicator}" not in description:
                    return True

    # Default to False if we can't determine
    return False


def extract_damage_types(raw_response):
    """
    Extract damage types from the raw response text.
    Focus only on question 3.
    Only extract types when damage is explicitly mentioned.

    Args:
        raw_response: The raw text response from the model

    Returns:
        List of damage types identified
    """
    if not raw_response:
        return []

    # First check if damage is detected
    if not extract_damage_detection(raw_response):
        return ["Healthy"]  # Return "Healthy" for no damage cases

    # Find the answer to question 3 about damage types
    q3_patterns = [
        r"3\.\s*\*\*if yes.*?\*\*\s*-\s*(.*?)(?=\n\n|\n4\.)",
        r"specific type of damage.*?\n\s*-\s*(.*?)(?=\n\n)"
    ]

    types_mentioned = set()

    for pattern in q3_patterns:
        match = re.search(pattern, raw_response.lower(), re.DOTALL)
        if match:
            answer = match.group(1).strip()

            # Check if the answer indicates no specific type
            if "no specific" in answer or "none" in answer:
                return []

            # Extract mentioned types using a more precise approach
            potential_types = {
                "crack": "Crack",
                "corrosion": "Corrosion",
                "rust": "Rust",
                "delamination": "Delamination",
                "fracture": "Fracture",
                "dent": "Dent",
                "ice": "Ice",
                "snow": "Snow",
                "surface peeling": "Surface Peeling",
                "peeling": "Surface Peeling",
                "wear": "Wear",
                "hole": "Hole",
                "edge splitting": "Edge Splitting",
                "burn mark": "Burn Mark",
                "charring": "Burn Mark"
            }

            for type_lower, type_proper in potential_types.items():
                # Simple check for presence without negation
                if type_lower in answer and f"no {type_lower}" not in answer:
                    types_mentioned.add(type_proper)

    return list(types_mentioned) if types_mentioned else []

def extract_severity(raw_response):
    """
    Extract severity rating from the raw response (question 5).

    Args:
        raw_response: The raw text response from the model

    Returns:
        Integer severity rating (1-5) or None if not found
    """
    if not raw_response:
        return None

    # Find the answer to question 5 about severity
    q5_patterns = [
        r"5\.\s*\*\*rate the severity.*?\*\*\s*-\s*(.*?)(?=\n\n|\Z)",
        r"severity rating.*?(\d)[^0-9]"
    ]

    for pattern in q5_patterns:
        match = re.search(pattern, raw_response.lower(), re.DOTALL)
        if match:
            answer = match.group(1).strip()

            # Extract numeric severity
            severity_match = re.search(r"(\d+)", answer)
            if severity_match:
                try:
                    return int(severity_match.group(1))
                except:
                    pass

    return None

def collect_damage_detection_results(rag_system, csv_path, output_file="detection_results.json"):
    """
    Process each image in the CSV, collect responses, and save to JSON file
    with extracted damage information directly from raw responses.
    Focuses only on questions 2, 3, and 5.

    Args:
        rag_system: DamageDetectionRAG instance
        csv_path: Path to CSV file containing image URLs
        output_file: Output JSON file path

    Returns:
        List of collected results
    """
    # Read CSV file
    test_data = pd.read_csv(csv_path)
    print(f"Loaded CSV with columns: {test_data.columns.tolist()}")

    # Ensure URL column exists (assuming second column is URL)
    url_column = test_data.columns[1] if len(test_data.columns) > 1 else None
    if not url_column:
        raise ValueError("CSV must have at least two columns, with the URL in the second column")

    # Get ground truth columns
    ground_truth_column = "has_damage" if "has_damage" in test_data.columns else None
    type_column = "damage_type" if "damage_type" in test_data.columns else None

    # Collect results
    all_results = []

    # Record start time
    start_time = time.time()

    # Process each URL
    for idx, row in test_data.iterrows():
        image_url = row[url_column]

        # Get ground truth (if available)
        ground_truth_damage = row.get(ground_truth_column) if ground_truth_column else None
        ground_truth_types = []
        if type_column and pd.notna(row.get(type_column)):
            type_val = row.get(type_column)
            if isinstance(type_val, str):
                ground_truth_types = [t.strip() for t in type_val.split(',')]

        print(f"Processing image {idx+1}/{len(test_data)}: {image_url}")

        # Record start time for single image analysis
        single_start_time = time.time()

        # Use RAG system to analyze
        try:
            # Call the detection method
            result = rag_system.detect_damage(image_url)

            # Extract raw response
            raw_response = ""
            if isinstance(result, dict):
                raw_response = result.get("raw_response", "")
            else:
                raw_response = str(result)

            # Extract damage information directly from raw response
            damage_detected = extract_damage_detection(raw_response)
            damage_types = extract_damage_types(raw_response)
            severity = extract_severity(raw_response)

            # Record response time
            response_time = time.time() - single_start_time

            # Create result dictionary
            result_entry = {
                "image_url": image_url,
                "ground_truth_damage": ground_truth_damage,
                "ground_truth_types": ground_truth_types,
                "response_time": response_time,
                "raw_response": raw_response,
                "extracted_damage_detected": damage_detected,
                "extracted_damage_types": damage_types,
                "extracted_severity": severity
            }

            # Add to results list
            all_results.append(result_entry)

            # Output basic information to monitor progress
            print(f"  Ground truth: {ground_truth_damage}")
            print(f"  Ground truth types: {ground_truth_types}")
            print(f"  Extracted damage: {damage_detected}")
            print(f"  Extracted types: {damage_types}")
            print(f"  Extracted severity: {severity}")
            print(f"  Response time: {response_time:.2f}s")
            print(f"  Response excerpt: {raw_response[:100]}...")

        except Exception as e:
            print(f"Error analyzing image: {str(e)}")
            all_results.append({
                "image_url": image_url,
                "ground_truth_damage": ground_truth_damage,
                "ground_truth_types": ground_truth_types,
                "error": str(e),
                "response_time": time.time() - single_start_time
            })

    # Calculate total time
    total_time = time.time() - start_time

    # Save all results to JSON file
    with open(output_file, 'w') as f:
        json.dump(all_results, f, indent=2)

    print(f"Evaluation completed. Total time: {total_time:.2f} seconds, Average per image: {total_time/len(test_data):.2f} seconds")
    print(f"Results saved to: {output_file}")

    return all_results
# Usage example
# store your test image links in csv and put the data file here:
results = collect_damage_detection_results(rag, "/content/**.csv")